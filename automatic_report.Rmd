---
title: "Résultats générés automatiquement"
author: "Lino"
date: "`r format(Sys.Date(), format = '%d %B %Y')`"
output:
  html_document:
  fig_width: 16 
  fig_height: 10 
params:
  beta: 0.98
  gamma: 0.5
  r: 0.03
  Nmoments: 3
  parameters_estimation: list()
  estimates: list()
  moments: list()
  label_moments: data.frame()
  output: list()
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, include=FALSE}
library(tablelight)
r <- params$r
beta <- params$beta
gamma <- params$gamma
delta <- 1/beta - 1
  
model <- readRDS("modele.rds")
population <- readRDS("tempfile.rds")
data <- readRDS("data.rds")
EP_2015 <- data[['EP_2015']]
EP_2018 <- data[['EP_2018']]
EP_lon <- data[['EP_lon']]
moments <- params$moments
list2env(params$parameters_estimation, envir = .GlobalEnv)

# output <- list(
#   "NelderMead" = params$output,
#   "moments" = params$moments
# )
output <- params$output

source("liste_moments.R")

if (!is.null(select_moments)){
  number_moments <- length(1:number_moments[1:number_moments %in% select_moments])
} else{
  number_moments <- number_moments
}
```

# Prolégomènes

Valeur des paramètres:

* r: `r r`
* gamma: `r gamma`
* beta: `r beta`
* Nmoments: `r number_moments`

Et donc delta: `r delta`




# Modèle d'héritage

```{r}
tf <- tempfile(fileext = ".html")
writeLines(light_table(
  model, type = "html"
), tf)
htmltools::includeHTML(tf)
```


# Qualité estimation minimum distance

```{r}
# OLD
df_moment <- mindist::loss_function(
#  match_call = TRUE,
  prediction_function = wealthyR:::model_capitulation,
  select_moments = select_moments,
  theta = c('beta' = as.numeric(beta),
            'gamma' = as.numeric(gamma),
            "r" = as.numeric(r)),
  EP_2015 = EP_2015,
  EP_lon = EP_lon,
  EP_2018 = EP_2018,
  data_microsimulated = data.table::copy(population),
  N_moments = number_moments,
  scale = scale_wealth,
  Hgiven_var = "hg",
  Hreceived_var = "hr",
  return_moment = TRUE
)

moments
```

Moments sélectionnés:


```{r labels}
knitr::kable(
  params$label_moments
)
```

| Critère | Deuxième étape | Première étape |
|---------|----------------|----------------|
| $\epsilon'\epsilon$ | `r sum(moments$moment_optimum$epsilon^2)` | `r sum(moments$moment_first_step$epsilon^2)` |
| $\epsilon' W \epsilon$ | `r output$NelderMead$NM_step2$value` | `r t(output$moments$moment_first_step$epsilon) %*% output$estimates$W_1 %*% output$moments$moment_first_step$epsilon` |
| $Q(\theta) = \frac{1}{M^2} \epsilon' W \epsilon$ | `r output$NelderMead$NM_step2$value/(length(output$moments$moment_optimum$epsilon)^2)` | `r as.numeric(t(output$moments$moment_first_step$epsilon) %*% output$estimates$W_1 %*% output$moments$moment_first_step$epsilon)/(length(output$moments$moment_optimum$epsilon)^2)`


# Estimation


```{r valparams}
print("Vecteur theta_hat: ")
params$estimates$theta_hat

print("Ecart-type: ")
params$estimates$se_theta_hat

print("Vecteur theta première étape: ")
params$estimates$theta_1
```

Les termes diagonaux de la matrice de poids $W$ sont :

```{r}
round(diag(params$estimates$W_1),5)
```



# Prédiction du modèle

```{r, echo = TRUE}
data_prediction_augm2 <- capitulation::life_cycle_model(
  population,
  wealthvar_survey = "K_observed",
  r = r,
  beta = beta,
  gamma = gamma,
  observation_year = 2009,
  income_var = "revenu",
  Hgiven_var = "hg",
  Hreceived_var = "hr",
  return_last = FALSE,
  get_capital_income = TRUE)
```

# Résultats

```{r Kage}
capitulation::plot_K_age(data_prediction_augm2)
```

```{r rKage}
capitulation::plot_rK_age(data_prediction_augm2)
```

```{r gini}
capitulation::plot_gini(data_prediction_augm2,
                        vars = c("revenu", "wealth", "Y"))
```


```{r}
LC1 <- ineq::Lc(data_prediction_augm2[annee==2020 & wealth>0]$wealth, plot = FALSE)
LC2 <- ineq::Lc(data_prediction_augm2[annee==2020 & wealth>0]$revenu, plot = FALSE)
df <- data.frame(p1 = LC1$p,
                 wealth = LC1$L,
                 uniform = LC1$p, 
                 y = LC2$L)
df <- data.table::data.table(reshape2::melt(df, id.vars = "p1"))

df[, 'lab' := "Pure equality"]
df[variable == "wealth", lab := "Wealth"]
df[variable == "y", lab := "Labor income"]


p <- ggplot2::ggplot(df) +
  ggplot2::geom_line(ggplot2::aes(x = p1, y = value, color = lab))+
  ggplot2::theme(legend.position="bottom") +
  ggplot2::scale_color_viridis_d() +
  ggplot2::labs(x = "", y = "", color = "") +
  ggplot2::theme(text = ggplot2::element_text(size=24),
                 axis.title = ggplot2::element_text(size=20,face="bold"))

p
```


# Graphs pour évaluer la qualité du fit


```{r}
gridExtra::grid.arrange(
  wealthyR::plot_moment_age(EP_2015, EP_2018, simulations = data_prediction_augm2,
                          by_survey = "AGEPR", by_simulation = 'age', scale = "log")$fit[[1]],
  wealthyR::plot_moment_age(EP_2015, EP_2018, simulations = data_prediction_augm2,
                          by_survey = "AGEPR", by_simulation = 'age', scale = "log")$fit[[2]]
)
```

Se référer au tableau pour les moments inclus dans l'analyse. 

* Moments 1 et 3:

```{r plotpic}
wealthyR::plot_moment_pic(EP_2015 = EP_2015,
                EP_2018 = EP_2018,
                simulations = data_prediction_augm2,
                scale = "log")
```


* Moment 2:

```{r plotvariation}
wealthyR::plot_moment_dK(
  EP_lon = EP_lon, simulations = data_prediction_augm2,
  scale = "log"
)
```

* Moments sur la distribution par âge du patrimoine (number ???):

```{r agemultiple}
wealthyR::plot_moment_age_multiple(
  EP_2015 = EP_2015,
  EP_2018 = EP_2018,
  simulations = data_prediction_augm2,
  scale = "level"
)
```


# Distribution des K0

Histogramme des K0:

```{r}
K0 <- data_prediction_augm2[order(Id,annee)][,.SD[1], by = "Id"]
ggplot2::ggplot(K0) +
  ggplot2::geom_histogram(
    ggplot2::aes(x = log(wealth), y = ..density..,
        fill = (annee>2009)), alpha = 0.4, position = "identity"
  ) +
  ggplot2::scale_fill_viridis_d()
```

Et la distribution sous-jacente:

```{r}
stats_desc <- function(x){
  return(c(mean(x), sd(x), quantile(x, p = c(.25,.5,.75,.9))))
}
K0[,'cohorte' := ifelse(annee>2009, "Après 2009", "Avant 2009")]
stats_K <- K0[,.(K = stats_desc(wealth)),
      by = "cohorte"]
stats_K[,stat := c("mean","sd",
         paste0("p",c(25,50,75, 90))), by = "cohorte"]
stats_K[,'K' := format(round(get('K')), big.mark = ",")]
data.table::dcast(stats_K, cohorte ~ ..., value.var = "K")
```
